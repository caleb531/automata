{"config":{"lang":["en"],"separator":"[\\s\\-\\.]","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Automata","text":"<p>Copyright 2016-2025 Caleb Evans Released under the MIT license</p> <p> </p> <p>Automata is a Python 3 library implementing structures and algorithms for manipulating finite automata, pushdown automata, and Turing machines. The algorithms have been optimized and are capable of processing large inputs. Visualization logic has also been implemented. This package is suitable for both researchers wishing to manipulate automata and for instructors teaching courses on theoretical computer science. See example jupyter notebooks.</p> <p>For an overview on automata theory, see this Wikipedia article, and for a more comprehensive introduction to each of these topics, see these lecture notes.</p> <p>The library requires Python 3.9 or newer.</p>"},{"location":"#installing","title":"Installing","text":"<p>You can install the latest version of Automata via pip:</p> <pre><code>pip install automata-lib\n</code></pre> <p>To install the optional visual dependencies, use the <code>visual</code> extra:</p> <pre><code>pip install 'automata-lib[visual]'\n</code></pre> <p>If you encounter errors building <code>pygraphviz</code>, you may need to install <code>graphviz</code>. See the instructions here.</p>"},{"location":"characteristics/","title":"Automaton Characteristics","text":""},{"location":"characteristics/#automaton-instances-are-immutable","title":"Automaton instances are immutable","text":"<p>All Automaton instances are fully immutable to protect against common pitfalls, such as mutating an automaton to an invalid state after it's already been validated.</p> <p>This means that if you wish to make a change to an automaton instance, you must retrieve its attributes as a dictionary (using the <code>input_parameters</code> property), make your desired change, then pass those parameters to the relevant constructor. For example:</p> <pre><code>from automata.fa.dfa import DFA\n\ndfa1 = DFA(\n    states={'q0', 'q1', 'q2'},\n    input_symbols={'0', '1'},\n    transitions={\n        'q0': {'0': 'q0', '1': 'q1'},\n        'q1': {'0': 'q0', '1': 'q2'},\n        'q2': {'0': 'q2', '1': 'q1'}\n    },\n    initial_state='q0',\n    final_states={'q1'}\n)\n# If you want to make a change, you must create a new instance; please note\n# that dfa1.input_parameters is always a deep copy of the input parameters for\n# dfa1 (in other words, mutating dfa1.input_parameters will not actually mutate\n# dfa1)\nparams = dfa1.input_parameters\nparams['final_states'] = {'q2'}\ndfa2 = DFA(**params)\n</code></pre>"},{"location":"characteristics/#enabling-mutable-automata","title":"Enabling mutable automata","text":"<p>Automaton immutability is enforced via a \"freeze\" step during object initialization that turns mutable parameters (such as sets or dicts) into their immutable counterparts (frozensets/frozendicts).</p> <p>If your application requires maximum performance, you can disable this conversion via the <code>allow_mutable_automata</code> global configuration option. If enabled, the user must ensure that their automaton instances are never modified, otherwise correct behavior cannot be guaranteed.</p> <pre><code>import automata.base.config as global_config\n\nglobal_config.allow_mutable_automata = True\n# The rest of your code...\n</code></pre>"},{"location":"characteristics/#automaton-instances-are-validated-by-default","title":"Automaton instances are validated by default","text":"<p>By default, all Automaton instances are checked for common inconsistencies when they are instantiated. If inconsistencies are found, the appropriate exception from <code>automata.base.exceptions</code> is raised.</p> <p>Because this validation can be performance-intensive for large automaton instances with many states/transitions, you can disable the automatic validation using the global configuration feature (introduced in v7):</p> <pre><code>import automata.base.config as global_config\n\nglobal_config.should_validate_automata = False\n\n# The rest of your code...\n</code></pre> <p>If, at any point, you wish to opt into validation for a specific Automaton instance, you can call the <code>validate</code> method:</p> <pre><code>my_automaton.validate()\n</code></pre>"},{"location":"migration/","title":"Automata Migration Guide","text":""},{"location":"migration/#backwards-incompatible-changes-from-v8-to-v9","title":"Backwards-incompatible changes from v8 to v9","text":""},{"location":"migration/#dependency-changes","title":"Dependency Changes","text":"<p>Python 3.8 support has been dropped. Please upgrade to Python 3.9 or later to use Automata v9.</p>"},{"location":"migration/#backwards-incompatible-changes-from-v7-to-v8","title":"Backwards-incompatible changes from v7 to v8","text":""},{"location":"migration/#dependency-changes_1","title":"Dependency Changes","text":"<p>Python 3.7 support has been dropped. Please upgrade to Python 3.8 or later to use Automata v8.</p> <p>Diagrams are no longer being generated using <code>pydot</code>; this dependency has been dropped in favor of using the <code>visual</code> optional dependency, which will install <code>pygraphviz</code> and <code>coloraide</code> used for generating figures. You should install this optional dependency if you wish to generate figures. This change was to allow for native support for displaying finite automaton in Jupyter notebooks. The style of the diagrams has been lifted from the visual automata package, so you should take a look at the diagrams generated and see if they are still satisfactory.</p> <p>Other new dependencies have been added, but these will be installed automatically along with v8 of the package.</p>"},{"location":"migration/#greater-support-for-partial-dfas","title":"Greater Support for Partial DFAs","text":"<p>There is now greater support for partial DFAs, which included changing the <code>DFA.from_nfa()</code> function to return a partial DFA instead of a complete one. To obtain a complete DFA, you must now call <code>DFA.from_nfa().to_complete(trap_state_name)</code>, where <code>trap_state_name</code> will be used as the name for a trap state if one needs to be added.</p>"},{"location":"migration/#type-hints","title":"Type Hints","text":"<p>Type hints have now been added, meaning that code which previously called functions with incorrect types may not have been flagged. See output from your typechecker for more information.</p>"},{"location":"migration/#nfafrom_regex-default-input-symbols","title":"NFA.from_regex default input symbols","text":"<p>The default set of input symbols for <code>NFA.from_regex</code> was changed to all ascii letters and digits. If needing to use a specific set of input symbols, use the <code>input_symbols</code> parameter.</p>"},{"location":"migration/#backwards-incompatible-changes-from-v6-to-v7","title":"Backwards-incompatible changes from v6 to v7","text":""},{"location":"migration/#immutable-instances","title":"Immutable instances","text":"<p>All Automaton instances are now fully immutable to protect against common pitfalls, such as mutating an automaton to an invalid state after it's already been validated.</p> <p>This means that if you wish to make a change to an automaton instance, you must retrieve its attributes as a dictionary (using the new <code>input_parameters</code> property), make your desired change, then pass those parameters to the relevant constructor. For example:</p> <pre><code>from automata.fa.dfa import DFA\n\ndfa1 = DFA(\n    states={'q0', 'q1', 'q2'},\n    input_symbols={'0', '1'},\n    transitions={\n        'q0': {'0': 'q0', '1': 'q1'},\n        'q1': {'0': 'q0', '1': 'q2'},\n        'q2': {'0': 'q2', '1': 'q1'}\n    },\n    initial_state='q0',\n    final_states={'q1'}\n)\n# You can still copy an automaton just fine\ndfa2 = dfa.copy()\n# If you want to make a change, you must create a new instance; please note\n# that dfa2.input_parameters is always a deep copy of the input parameters for\n# dfa2 (in other words, mutating dfa2.input_parameters will not actually mutate\n# dfa2)\nparams = dfa2.input_parameters\nparams['final_states'] = {'q2'}\ndfa3 = DFA(**params)\n</code></pre>"},{"location":"migration/#renamed-regex-module","title":"Renamed Regex Module","text":"<p>The <code>automata.base.regex</code> module has been renamed to <code>automata.regex.regex</code> alongside the other regular expression-related modules.</p>"},{"location":"migration/#dfaminify-defaults","title":"DFA.minify() defaults","text":"<p>The default value of the <code>retain_names</code> parameter for <code>DFA.minify()</code> has been corrected from <code>True</code> to <code>False</code>; the API documentation has always stated that the default value should be <code>False</code>, however the default value in the code was actually <code>True</code>; therefore, the code has been updated to match the documentation (#59)  - Since this code correction may break existing developer code, this is labeled    as a backwards-incompatible change rather than just a mere bugfix</p>"},{"location":"migration/#backwards-incompatible-changes-from-v5-to-v6","title":"Backwards-incompatible changes from v5 to v6","text":"<p>Python 3.6 support has been dropped, since it has been end-of-life since December 2021. Please upgrade to Python 3.7 or later to use Automata v6.</p> <p>The networkx package has been added as a required dependency, providing substantial performance improvements for certain DFA/NFA methods, and also streamlining the code to improve maintainability.</p>"},{"location":"migration/#backwards-incompatible-changes-from-v4-to-v5","title":"Backwards-incompatible changes from v4 to v5","text":"<p>Python 3.5 support has been dropped, since it has been end-of-life since September 2020. Please upgrade to Python 3.6 or later to use Automata v5.</p> <p>To support the new graph visualization capabilities, <code>pydot</code> has been added as a project dependency. The <code>pydot</code> package will be installed when you run <code>pip install automata-lib</code>.</p>"},{"location":"migration/#backwards-incompatible-changes-from-v3-to-v4","title":"Backwards-incompatible changes from v3 to v4","text":"<p>The only backwards-incompatible change from v3 to v4 is that support for Python 3.4 has been dropped. This is because Python 3.4 has reached end-of-life, and will no longer receive updates. For more information, please refer to the Python 3.4.10 release notes.</p> <p>There have been no API changes from v3 to v4.</p>"},{"location":"migration/#backwards-incompatible-changes-from-v2-to-v3","title":"Backwards-incompatible changes from v2 to v3","text":"<p>There have been a number of backwards-incompatible changes from Automata v2 to v3 to support the new features, including:</p>"},{"location":"migration/#some-types-made-immutable","title":"Some types made immutable","text":"<p>The <code>PDAStack</code> type is now immutable and hashable; it still represents the current stack of a PDA.</p> <p>Likewise, the <code>TMTape</code> is now immutable and hashable; it still represents the tape of a TM and the current cursor position.</p>"},{"location":"migration/#copy-methods-removed-for-now-immutable-types","title":"copy() methods removed for (now) immutable types","text":"<p>The <code>copy</code> methods on <code>TMTape</code> and <code>PDAStack</code> have been removed, since they are now immutable types. This change is similar to how <code>list</code> has a <code>copy()</code> method but <code>tuple</code> does not.</p>"},{"location":"migration/#acceptance-mode-of-pdas-is-now-configurable","title":"Acceptance mode of PDAs is now configurable","text":"<p><code>DPDA</code> and <code>NPDA</code> have a new config option which specifies when to accept. This can be either <code>'empty_stack'</code>, <code>'final_state'</code> or <code>'both'</code>. The default is <code>'both'</code>.</p>"},{"location":"migration/#backwards-incompatible-changes-from-v1-to-v2","title":"Backwards-incompatible changes from v1 to v2","text":"<p>There have been a number of backwards-incompatible changes from Automata v1 to v2 to clean up the API, including:</p>"},{"location":"migration/#renames","title":"Renames","text":"<p>The following methods and classes have been renamed for better clarity:</p>"},{"location":"migration/#shared-module","title":"Shared module","text":"<p>The <code>automata.shared</code> package has been renamed to <code>automata.base</code>.</p> <p>Before: <pre><code>from automata.shared.automaton import Automaton\nfrom automata.shared.exceptions import FinalStateError\n</code></pre></p> <p>After: <pre><code>from automata.base.automaton import Automaton\nfrom automata.base.exceptions import FinalStateError\n</code></pre></p>"},{"location":"migration/#input-validation-methods","title":"Input validation methods","text":"<p>The <code>validate_input()</code> method has been renamed to <code>read_input()</code>. The <code>validate_input(step=True)</code> form has also been converted to the standalone method <code>read_input_stepwise()</code>.</p> <p>Before: <pre><code>final_state = dfa.validate_input('0011')\nsteps = dfa.validate_input('0011', step=True)\n</code></pre></p> <p>After: <pre><code>final_state = dfa.read_input('0011')\nsteps = dfa.read_input_stepwise('0011')\n</code></pre></p>"},{"location":"migration/#automaton-validation-methods","title":"Automaton validation methods","text":"<p>The <code>validate_self()</code> method has been renamed to <code>validate()</code>.</p> <p>Before: <pre><code>dfa.validate_self()\n</code></pre></p> <p>After: <pre><code>dfa.validate()\n</code></pre></p>"},{"location":"migration/#exceptions","title":"Exceptions","text":"<p>The top-level <code>*Error</code> exception classes has been renamed to <code>*Exception</code>.</p> <p>Before: <pre><code>from automata.shared.exceptions import AutomatonError\nfrom automata.shared.exceptions import RejectionError\nfrom automata.pda.exceptions import PDAError\nfrom automata.tm.exceptions import TMError\n</code></pre></p> <p>After: <pre><code>from automata.base.exceptions import AutomatonException\nfrom automata.base.exceptions import RejectionException\nfrom automata.pda.exceptions import PDAException\nfrom automata.tm.exceptions import TMException\n</code></pre></p>"},{"location":"migration/#constructor-polymorphism-removed","title":"Constructor polymorphism removed","text":"<p>In v1, you could copy an automaton (or convert it to another type) by passing it into the constructor for an Automaton subtype.</p>"},{"location":"migration/#copying-an-automaton","title":"Copying an automaton","text":"<p>Before: <pre><code>dfa = DFA(dfa)\n</code></pre></p> <p>After: <pre><code>dfa = dfa.copy()\n</code></pre></p>"},{"location":"migration/#converting-nfa-to-dfa","title":"Converting NFA to DFA","text":"<p>Before: <pre><code>dfa = DFA(nfa)\n</code></pre></p> <p>After: <pre><code>dfa = DFA.from_nfa(nfa)\n</code></pre></p>"},{"location":"migration/#converting-dfa-to-nfa","title":"Converting DFA to NFA","text":"<p>Before: <pre><code>nfa = NFA(dfa)\n</code></pre></p> <p>After: <pre><code>nfa = NFA.from_dfa(dfa)\n</code></pre></p>"},{"location":"people/","title":"People","text":""},{"location":"people/#maintainers","title":"Maintainers","text":"<ul> <li>caleb531</li> <li>eliotwrobson</li> </ul>"},{"location":"people/#contributors","title":"Contributors","text":"<ul> <li>lewiuberg</li> <li>YtvwlD</li> <li>dengl11</li> <li>Tagl</li> <li>CamiloMartinezM</li> <li>abhinavsinha-adrino</li> <li>skyien-z</li> <li>dsr20030703</li> </ul>"},{"location":"api/","title":"API","text":"<p>This is the API documentation generated by the class and method docstrings for the <code>automata</code> package.</p>"},{"location":"api/base-exception-classes/","title":"Base exception classes","text":"<p>Exception classes shared by all automata.</p>"},{"location":"api/base-exception-classes/#automata.base.exceptions.AutomatonException","title":"<code>AutomatonException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>The base class for all automaton-related errors.</p>"},{"location":"api/base-exception-classes/#automata.base.exceptions.DiagramException","title":"<code>DiagramException</code>","text":"<p>               Bases: <code>AutomatonException</code></p> <p>The diagram cannot be produced</p>"},{"location":"api/base-exception-classes/#automata.base.exceptions.EmptyLanguageException","title":"<code>EmptyLanguageException</code>","text":"<p>               Bases: <code>AutomatonException</code></p> <p>The operation cannot be performed because the language is empty</p>"},{"location":"api/base-exception-classes/#automata.base.exceptions.FinalStateError","title":"<code>FinalStateError</code>","text":"<p>               Bases: <code>AutomatonException</code></p> <p>A final state fails to meet some required condition.</p>"},{"location":"api/base-exception-classes/#automata.base.exceptions.InfiniteLanguageException","title":"<code>InfiniteLanguageException</code>","text":"<p>               Bases: <code>AutomatonException</code></p> <p>The operation cannot be performed because the language is infinite</p>"},{"location":"api/base-exception-classes/#automata.base.exceptions.InitialStateError","title":"<code>InitialStateError</code>","text":"<p>               Bases: <code>AutomatonException</code></p> <p>The initial state fails to meet some required condition.</p>"},{"location":"api/base-exception-classes/#automata.base.exceptions.InvalidRegexError","title":"<code>InvalidRegexError</code>","text":"<p>               Bases: <code>RegexException</code></p> <p>Regular expression is invalid</p>"},{"location":"api/base-exception-classes/#automata.base.exceptions.InvalidStateError","title":"<code>InvalidStateError</code>","text":"<p>               Bases: <code>AutomatonException</code></p> <p>A state is not a valid state for this automaton.</p>"},{"location":"api/base-exception-classes/#automata.base.exceptions.InvalidSymbolError","title":"<code>InvalidSymbolError</code>","text":"<p>               Bases: <code>AutomatonException</code></p> <p>A symbol is not a valid symbol for this automaton.</p>"},{"location":"api/base-exception-classes/#automata.base.exceptions.LexerError","title":"<code>LexerError</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RegexException</code></p> <p>An exception raised for issues in lexing</p>"},{"location":"api/base-exception-classes/#automata.base.exceptions.MissingStateError","title":"<code>MissingStateError</code>","text":"<p>               Bases: <code>AutomatonException</code></p> <p>A state is missing from the automaton definition.</p>"},{"location":"api/base-exception-classes/#automata.base.exceptions.MissingSymbolError","title":"<code>MissingSymbolError</code>","text":"<p>               Bases: <code>AutomatonException</code></p> <p>A symbol is missing from the automaton definition.</p>"},{"location":"api/base-exception-classes/#automata.base.exceptions.RegexException","title":"<code>RegexException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>The base class for all regular expression related errors</p>"},{"location":"api/base-exception-classes/#automata.base.exceptions.RejectionException","title":"<code>RejectionException</code>","text":"<p>               Bases: <code>AutomatonException</code></p> <p>The input was rejected by the automaton.</p>"},{"location":"api/base-exception-classes/#automata.base.exceptions.SymbolMismatchError","title":"<code>SymbolMismatchError</code>","text":"<p>               Bases: <code>AutomatonException</code></p> <p>The input symbols between the given automata do not match</p>"},{"location":"api/class-automaton/","title":"class Automaton(metaclass=ABCMeta)","text":"<p>An abstract base class for all automata, including Turing machines.</p>"},{"location":"api/class-automaton/#automata.base.automaton.Automaton.input_parameters","title":"<code>input_parameters</code>  <code>property</code>","text":"<p>Return the public attributes for this automaton.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A dictionary mapping attribute names to their values.</p>"},{"location":"api/class-automaton/#automata.base.automaton.Automaton.accepts_input","title":"<code>accepts_input(input_str)</code>","text":"<p>Return True if this automaton accepts the given input.</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>The input string to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if this automaton accepts the given input; False otherwise.</p>"},{"location":"api/class-automaton/#automata.base.automaton.Automaton.copy","title":"<code>copy()</code>","text":"<p>Create a deep copy of the automaton.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A deep copy of the automaton.</p>"},{"location":"api/class-automaton/#automata.base.automaton.Automaton.read_input","title":"<code>read_input(input_str)</code>","text":"<p>Check if the given string is accepted by this automaton.</p> <p>Return the automaton's final configuration if this string is valid.</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>The input string to check.</p> required <p>Returns:</p> Type Description <code>AutomatonStateT</code> <p>The final configuration of the automaton after reading the input.</p>"},{"location":"api/class-automaton/#automata.base.automaton.Automaton.read_input_stepwise","title":"<code>read_input_stepwise(input_str)</code>  <code>abstractmethod</code>","text":"<p>Return a generator that yields each step while reading input.</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>The input string to read.</p> required <p>Yields:</p> Type Description <code>Generator[Any, None, None]</code> <p>A generator that yields the current configuration of the automaton after each step of reading input.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If this method has not been implemented by a subclass.</p>"},{"location":"api/class-automaton/#automata.base.automaton.Automaton.validate","title":"<code>validate()</code>  <code>abstractmethod</code>","text":"<p>Raises an exception if this automaton is not internally consistent.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If this method has not been implemented by a subclass.</p>"},{"location":"api/regular-expressions/","title":"Regular Expressions","text":"<p>A set of tools for working with regular expressions. Can recognize regular expressions over the alphabet of unicode characters and subsets of these, excluding blanks.</p> <p>A regular expression with the following operations only are supported in this library:</p> <ul> <li><code>*</code>: Kleene star operation, language repeated zero or more times. Ex: <code>a*</code>,<code>(ab)*</code></li> <li><code>+</code>: Kleene plus operation, language repeated one or more times. Ex: <code>a+</code>,<code>(ab)+</code></li> <li><code>?</code>: Language repeated zero or one time. Ex: <code>a?</code></li> <li>Concatenation. Ex: <code>abcd</code></li> <li><code>|</code>: Union. Ex: <code>a|b</code></li> <li><code>&amp;</code>: Intersection. Ex: <code>a&amp;b</code></li> <li><code>.</code>: Wildcard. Ex: <code>a.b</code></li> <li><code>^</code>: Shuffle. Ex: <code>a^b</code></li> <li><code>{}</code>: Quantifiers expressing finite repetitions. Ex: <code>a{1,2}</code>,<code>a{3,}</code></li> <li><code>()</code>: The empty string.</li> <li><code>(...)</code>: Grouping.</li> </ul> <p>This is similar to the Python <code>re</code> module, but this library does not support any special characters other than those given above. All regular languages can be written with these.</p>"},{"location":"api/regular-expressions/#automata.regex.regex.isequal","title":"<code>isequal(re1, re2, *, input_symbols=None)</code>","text":"<p>Whether both regular expressions are equivalent.</p> <p>Parameters:</p> Name Type Description Default <code>re1</code> <code>str</code> <p>The first regular expression as a string.</p> required <code>re2</code> <code>str</code> <p>The second regular expression as a string.</p> required <code>input_symbols</code> <code>Optional[AbstractSet[str]]</code> <p>The set of input symbols when doing the comparison. Defaults to all ascii letters and digits.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the regular expressions are equivalent.</p>"},{"location":"api/regular-expressions/#automata.regex.regex.issubset","title":"<code>issubset(re1, re2, *, input_symbols=None)</code>","text":"<p>Whether re1 is a subset of re2.</p> <p>Parameters:</p> Name Type Description Default <code>re1</code> <code>str</code> <p>The first regular expression as a string.</p> required <code>re2</code> <code>str</code> <p>The second regular expression as a string.</p> required <code>input_symbols</code> <code>Optional[AbstractSet[str]]</code> <p>The set of input symbols when doing the comparison. Defaults to all ascii letters and digits.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if re1 is a subset of re2.</p>"},{"location":"api/regular-expressions/#automata.regex.regex.issuperset","title":"<code>issuperset(re1, re2, *, input_symbols=None)</code>","text":"<p>Whether re1 is a superset of re2.</p> <p>Parameters:</p> Name Type Description Default <code>re1</code> <code>str</code> <p>The first regular expression as a string.</p> required <code>re2</code> <code>str</code> <p>The second regular expression as a string.</p> required <code>input_symbols</code> <code>Optional[AbstractSet[str]]</code> <p>The set of input symbols when doing the comparison. Defaults to all ascii letters and digits.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if re1 is a superset of re2.</p>"},{"location":"api/regular-expressions/#automata.regex.regex.validate","title":"<code>validate(regex)</code>","text":"<p>Raises an exception if the input regular expression is invalid.</p> <p>Raises:</p> Type Description <code>InvalidRegexError</code> <p>Raised if the regex given as input is not well defined.</p>"},{"location":"api/fa/class-dfa/","title":"class DFA(FA)","text":"<p>Classes and methods for working with deterministic finite automata.</p>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA","title":"<code>DFA</code>","text":"<p>               Bases: <code>FA</code></p> <p>The <code>DFA</code> class is a subclass of <code>FA</code> and represents a deterministic finite automaton.</p> <p>Every DFA can be rendered natively inside of a Jupyter notebook (automatically calling <code>show_diagram</code> without any arguments) if installed with the <code>visual</code> optional dependency.</p> <p>Parameters:</p> Name Type Description Default <code>states</code> <code>AbstractSet[DFAStateT]</code> <p>Set of the DFA's valid states.</p> required <code>input_symbols</code> <code>AbstractSet[str]</code> <p>Set of the DFA's valid input symbols, each of which is a singleton string</p> required <code>transitions</code> <code>Mapping[DFAStateT, Mapping[str, DFAStateT]]</code> <p>Dict consisting of the transitions for each state. Each key is a state name, and each value is another dict which maps a symbol (the key) to a state (the value).</p> required <code>initial_state</code> <code>DFAStateT</code> <p>The initial state for this DFA.</p> required <code>final_states</code> <code>AbstractSet[DFAStateT]</code> <p>A set of final states for this DFA</p> required <code>allow_partial</code> <code>bool</code> <p>By default, each DFA state must have a transition to every input symbol; if this parameter is <code>True</code>, you can disable this characteristic (such that any DFA state can have fewer transitions than input symbols). Note that a DFA must always have every state represented in the transition dictionary, even if there are no transitions on input symbols leaving a state (dictionary is left empty in that case).</p> <code>False</code>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA.animate_reading_input","title":"<code>animate_reading_input(input_str, preview=False)</code>","text":"<p>Render the animation of the DFA reading the input string stepwise and save the animation in the media/ folder.</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>The input string to read.</p> required <code>preview</code> <code>bool</code> <p>If true, opens scene in a file viewer.</p> <code>False</code>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA.cardinality","title":"<code>cardinality()</code>","text":"<p>Returns the cardinality of the language represented by the DFA.</p> <p>Returns:</p> Type Description <code>int</code> <p>The cardinality of the language accepted by self.</p> <p>Raises:</p> Type Description <code>InfiniteLanguageException</code> <p>Raised if self accepts an infinite language.</p>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA.clear_cache","title":"<code>clear_cache()</code>","text":"<p>Resets the word and count caches. Can be called if too much memory is being used.</p>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA.complement","title":"<code>complement(*, retain_names=False, minify=True)</code>","text":"<p>Creates a DFA which accepts an input if and only if the old one does not. Minifies by default. Unreachable states are always removed. Partial DFAs are converted into complete ones.</p> <p>Parameters:</p> Name Type Description Default <code>retain_names</code> <code>bool</code> <p>Whether to retain state names through the complement and optional minify.</p> <code>False</code> <code>minify</code> <code>bool</code> <p>Whether to minify the result of the complement of the input DFA.</p> <code>True</code> <p>Returns:</p> Type Description <code>Self</code> <p>A DFA accepting the complement of the input DFA. State minimal by default.</p>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA.count_mod","title":"<code>count_mod(input_symbols, k, *, remainders=None, symbols_to_count=None)</code>  <code>classmethod</code>","text":"<p>Directly computes a DFA that counts given symbols and accepts all strings where the remainder of division by k is in the set of remainders given. The default value of remainders is {0} and all symbols are counted by default.</p> <p>Parameters:</p> Name Type Description Default <code>input_symbols</code> <code>AbstractSet[str]</code> <p>The set of input symbols to construct the DFA over.</p> required <code>k</code> <code>int</code> <p>The number to divide the length by.</p> required <code>remainders</code> <code>Optional[AbstractSet[int]]</code> <p>The remainders to accept. If set to None, defaults to {0}.</p> <code>None</code> <code>symbols_to_count</code> <code>Optional[AbstractSet[str]]</code> <p>The input symbols to count towards the length of words to accepts. If set to None, counts all symbols.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The DFA accepting the desired language.</p>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA.count_words_of_length","title":"<code>count_words_of_length(k)</code>","text":"<p>Returns count of words of length k accepted by the DFA.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>The desired word length.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of words of length k accepted by self.</p>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA.difference","title":"<code>difference(other, *, retain_names=False, minify=True)</code>","text":"<p>Takes as input two DFAs M1 and M2 which accept languages L1 and L2 respectively. Returns a DFA which accepts the difference of L1 and L2.</p> <p>Minifies by default. Unreachable states are always removed. If either input DFA is partial, the result is partial.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>DFA</code> <p>The DFA we want to take a difference with.</p> required <code>retain_names</code> <code>bool</code> <p>Whether to retain state names through the difference and optional minify.</p> <code>False</code> <code>minify</code> <code>bool</code> <p>Whether to minify the result of the difference of the two DFAs.</p> <code>True</code> <p>Returns:</p> Type Description <code>Self</code> <p>A DFA accepting the difference of the two input DFAs. State minimal by default.</p>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA.empty_language","title":"<code>empty_language(input_symbols)</code>  <code>classmethod</code>","text":"<p>Directly computes the minimal DFA rejecting all strings.</p> <p>Parameters:</p> Name Type Description Default <code>input_symbols</code> <code>AbstractSet[str]</code> <p>The set of input symbols to construct the DFA over.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The DFA accepting the desired language.</p>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA.from_finite_language","title":"<code>from_finite_language(input_symbols, language, as_partial=True)</code>  <code>classmethod</code>","text":"<p>Directly computes the minimal DFA accepting the finite language given as input. Uses the algorithm described in Finite-State Techniques by Mihov and Schulz, Chapter 10</p> <p>Parameters:</p> Name Type Description Default <code>input_symbols</code> <code>AbstractSet[str]</code> <p>The set of input symbols to construct the DFA over.</p> required <code>language</code> <code>AbstractSet[str]</code> <p>The language to accept.</p> required <code>as_partial</code> <code>bool</code> <p>Whether or not to construct this as a partial DFA.</p> <code>True</code> <p>Returns:</p> Type Description <code>Self</code> <p>The DFA accepting the desired language.</p>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA.from_nfa","title":"<code>from_nfa(target_nfa, *, retain_names=False, minify=True)</code>  <code>classmethod</code>","text":"<p>Initialize this DFA as one equivalent to the given NFA. Note that this usually returns a partial DFA by default.</p> <p>Parameters:</p> Name Type Description Default <code>target_nfa</code> <code>NFA</code> <p>The NFA to construct an equivalent DFA for.</p> required <code>retain_names</code> <code>bool</code> <p>Whether or not to retain state names during processing.</p> <code>False</code> <code>minify</code> <code>bool</code> <p>Whether or not to minify the DFA resulting from the input NFA.</p> <code>True</code> <p>Returns:</p> Type Description <code>Self</code> <p>The DFA accepting the language of the input NFA.</p>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA.from_prefix","title":"<code>from_prefix(input_symbols, prefix, *, contains=True, as_partial=True)</code>  <code>classmethod</code>","text":"<p>Directly computes the minimal DFA accepting strings with the given prefix. If <code>contains</code> is set to <code>False</code> then the complement is constructed instead.</p> <p>Parameters:</p> Name Type Description Default <code>input_symbols</code> <code>AbstractSet[str]</code> <p>The set of input symbols to construct the DFA over.</p> required <code>prefix</code> <code>str</code> <p>The prefix of strings that are accepted by this DFA.</p> required <code>contains</code> <code>bool</code> <p>Whether or not to construct the compliment DFA.</p> <code>True</code> <code>as_partial</code> <code>bool</code> <p>Whether or not to construct this DFA as a partial DFA.</p> <code>True</code> <p>Returns:</p> Type Description <code>Self</code> <p>The DFA accepting the desired language.</p>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA.from_subsequence","title":"<code>from_subsequence(input_symbols, subsequence, *, contains=True)</code>  <code>classmethod</code>","text":"<p>Directly computes the minimal DFA recognizing strings containing the given subsequence. If <code>contains</code> is set to <code>False</code>, then the complement is constructed instead.</p> <p>Parameters:</p> Name Type Description Default <code>input_symbols</code> <code>AbstractSet[str]</code> <p>The set of input symbols to construct the DFA over.</p> required <code>subsequence</code> <code>str</code> <p>The target subsequence of strings that are accepted by this DFA.</p> required <code>contains</code> <code>bool</code> <p>Whether or to construct the compliment DFA.</p> <code>True</code> <p>Returns:</p> Type Description <code>Self</code> <p>The DFA accepting the desired language.</p>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA.from_substring","title":"<code>from_substring(input_symbols, substring, *, contains=True, must_be_suffix=False)</code>  <code>classmethod</code>","text":"<p>Directly computes the minimal DFA recognizing strings containing the given substring. If <code>contains</code> is set to <code>False</code> then the complement is constructed instead. If <code>must_be_suffix</code> is set to <code>True</code>, then the substring must be a suffix instead.</p> <p>Parameters:</p> Name Type Description Default <code>input_symbols</code> <code>AbstractSet[str]</code> <p>The set of input symbols to construct the DFA over.</p> required <code>substring</code> <code>str</code> <p>The substring of strings that are accepted by this DFA.</p> required <code>contains</code> <code>bool</code> <p>Whether or to construct the compliment DFA.</p> <code>True</code> <code>must_be_suffix</code> <code>bool</code> <p>Whether or not the target substring must be a suffix.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>The DFA accepting the desired language.</p>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA.from_substrings","title":"<code>from_substrings(input_symbols, substrings, *, contains=True, must_be_suffix=False)</code>  <code>classmethod</code>","text":"<p>Directly computes a DFA recognizing strings containing at least one of the given substrings. The implementation is based on the Aho-Corasick string-searching algorithm. If <code>contains</code> is set to <code>False</code>, then the complement is constructed instead. If <code>must_be_suffix</code> is set to <code>True</code>, then the each substring must be a suffix instead.</p> <p>Parameters:</p> Name Type Description Default <code>input_symbols</code> <code>AbstractSet[str]</code> <p>The set of input symbols to construct the DFA over.</p> required <code>substrings</code> <code>str</code> <p>The set of strings to be recognized by this DFA.</p> required <code>contains</code> <code>bool</code> <p>Whether or to construct the compliment DFA.</p> <code>True</code> <code>must_be_suffix</code> <code>bool</code> <p>Whether or not the target substrings must be a suffix.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>The DFA accepting the desired language.</p>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA.from_suffix","title":"<code>from_suffix(input_symbols, suffix, *, contains=True)</code>  <code>classmethod</code>","text":"<p>Directly computes the minimal DFA recognizing strings with the given suffix. If <code>contains</code> is set to <code>False</code>, then the complement is constructed instead.</p> <p>Parameters:</p> Name Type Description Default <code>input_symbols</code> <code>AbstractSet[str]</code> <p>The set of input symbols to construct the DFA over.</p> required <code>suffix</code> <code>str</code> <p>The suffix of strings that are accepted by this DFA.</p> required <code>contains</code> <code>bool</code> <p>Whether or not to construct the compliment DFA.</p> <code>True</code> <p>Returns:</p> Type Description <code>Self</code> <p>The DFA accepting the desired language.</p>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA.intersection","title":"<code>intersection(other, *, retain_names=False, minify=True)</code>","text":"<p>Takes as input two DFAs M1 and M2 which accept languages L1 and L2 respectively. Returns a DFA which accepts the intersection of L1 and L2.</p> <p>Minifies by default. Unreachable states are always removed. If either input DFA is partial, the result is partial.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>DFA</code> <p>The DFA we want to take a intersection with.</p> required <code>retain_names</code> <code>bool</code> <p>Whether to retain state names through the intersection and optional minify.</p> <code>False</code> <code>minify</code> <code>bool</code> <p>Whether to minify the result of the intersection of the two DFAs.</p> <code>True</code> <p>Returns:</p> Type Description <code>Self</code> <p>A DFA accepting the intersection of the two input DFAs. State minimal by default.</p>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA.isdisjoint","title":"<code>isdisjoint(other)</code>","text":"<p>Returns True if the language accepted by self is disjoint from that of other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>DFA</code> <p>The other DFA we are comparing our language against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if self is disjoint from other, False otherwise.</p>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA.isempty","title":"<code>isempty()</code>","text":"<p>Returns True if the language accepted by self is empty.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if self accepts the empty language, False otherwise.</p>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA.isfinite","title":"<code>isfinite()</code>","text":"<p>Returns True if the language accepted by self is finite.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if self accepts a finite language, False otherwise.</p>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA.issubset","title":"<code>issubset(other)</code>","text":"<p>Returns True if the language accepted by self is a subset of that of other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>DFA</code> <p>The other DFA we are comparing our language against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if self is a subset of other, False otherwise.</p>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA.issuperset","title":"<code>issuperset(other)</code>","text":"<p>Returns True if the language accepted by self is a superset of that of other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>DFA</code> <p>The other DFA we are comparing our language against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if self is a superset of other, False otherwise.</p>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA.iter_transitions","title":"<code>iter_transitions()</code>","text":"<p>Iterate over all transitions in the DFA. Each transition is a tuple of the form (from_state, to_state, symbol).</p> <p>Returns:</p> Type Description <code>Generator[Tuple[DFAStateT, DFAStateT, str], None, None]</code> <p>The desired generator over the DFA transitions.</p>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA.maximum_word_length","title":"<code>maximum_word_length()</code>","text":"<p>Returns the length of the longest word in the language accepted by the DFA In the case of infinite languages, <code>None</code> is returned.</p> <p>Returns:</p> Type Description <code>Optional[int]</code> <p>The length of the longest word accepted by self. None if the language is infinite.</p> <p>Raises:</p> Type Description <code>EmptyLanguageException</code> <p>Raised if self accepts the empty language.</p>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA.minify","title":"<code>minify(retain_names=False)</code>","text":"<p>Create a minimal DFA which accepts the same inputs as this DFA.</p> <p>First, non-reachable states are removed. Then, indistinguishable states are merged using Hopcroft's Algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>retain_names</code> <code>bool</code> <p>Whether to retain original names when merging states. New names are from 0 to n-1.</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>A state-minimal equivalent DFA. May be complete in some cases if the input is partial.</p>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA.minimum_word_length","title":"<code>minimum_word_length()</code>","text":"<p>Returns the length of the shortest word in the language accepted by the DFA.</p> <p>Returns:</p> Type Description <code>int</code> <p>The length of the shortest word accepted by self.</p> <p>Raises:</p> Type Description <code>EmptyLanguageException</code> <p>Raised if self accepts an empty language.</p>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA.nth_from_end","title":"<code>nth_from_end(input_symbols, symbol, n)</code>  <code>classmethod</code>","text":"<p>Directly computes the minimal DFA which accepts all words whose <code>n</code>th character from the end is <code>symbol</code>, where <code>n</code> is a positive integer.</p> <p>Parameters:</p> Name Type Description Default <code>input_symbols</code> <code>AbstractSet[str]</code> <p>The set of input symbols to construct the DFA over.</p> required <code>symbol</code> <code>str</code> <p>The target input symbol.</p> required <code>n</code> <code>int</code> <p>The position of the target input symbol.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The DFA accepting the desired language.</p>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA.nth_from_start","title":"<code>nth_from_start(input_symbols, symbol, n)</code>  <code>classmethod</code>","text":"<p>Directly computes the minimal DFA which accepts all words whose <code>n</code>th character from the start is <code>symbol</code>, where <code>n</code> is a positive integer.</p> <p>Parameters:</p> Name Type Description Default <code>input_symbols</code> <code>AbstractSet[str]</code> <p>The set of input symbols to construct the DFA over.</p> required <code>symbol</code> <code>str</code> <p>The target input symbol.</p> required <code>n</code> <code>int</code> <p>The position of the target input symbol.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The DFA accepting the desired language.</p>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA.of_length","title":"<code>of_length(input_symbols, *, min_length=0, max_length=None, symbols_to_count=None)</code>  <code>classmethod</code>","text":"<p>Directly computes the minimal DFA recognizing strings whose length is between <code>min_length</code> and <code>max_length</code>, inclusive. To allow arbitrarily long words, the value <code>None</code> can be passed in for <code>max_length</code>.</p> <p>Parameters:</p> Name Type Description Default <code>input_symbols</code> <code>AbstractSet[str]</code> <p>The set of input symbols to construct the DFA over.</p> required <code>min_length</code> <code>int</code> <p>The minimum length of strings to be accepted by this DFA.</p> <code>0</code> <code>max_length</code> <code>Optional[int]</code> <p>The maximum length of strings to be accepted by this DFA. If set to None, there is no maximum.</p> <code>None</code> <code>symbols_to_count</code> <code>Optional[AbstractSet[str]]</code> <p>The input symbols to count towards the length of words to accepts. If set to None, counts all symbols.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The DFA accepting the desired language.</p>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA.predecessor","title":"<code>predecessor(input_str, *, strict=True, key=None, min_length=0, max_length=None)</code>","text":"<p>Returns the first string accepted by the DFA that comes before the input string in lexicographical order.</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>The starting input string.</p> required <code>strict</code> <code>bool</code> <p>If set to false and input_str is accepted by the DFA, input_str will be returned.</p> <code>True</code> <code>key</code> <code>Optional[Callable]</code> <p>Function for defining custom lexicographical ordering. Defaults to using the standard string ordering.</p> <code>None</code> <code>min_length</code> <code>int</code> <p>Limits generation to words with at least the given length.</p> <code>0</code> <code>max_length</code> <code>Optional[int]</code> <p>Limits generation to words with at most the given length.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The first string accepted by the DFA lexicographically before input_string.</p> <p>Raises:</p> Type Description <code>InfiniteLanguageException</code> <p>Raised if the language accepted by self is infinite, as we cannot generate predecessors in this case.</p>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA.predecessors","title":"<code>predecessors(input_str, *, strict=True, key=None, min_length=0, max_length=None)</code>","text":"<p>Generates all strings that come before the input string in lexicographical order.</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>The starting input string.</p> required <code>strict</code> <code>bool</code> <p>If set to false and input_str is accepted by the DFA, input_str will be returned.</p> <code>True</code> <code>key</code> <code>Optional[Callable]</code> <p>Function for defining custom lexicographical ordering. Defaults to using the standard string ordering.</p> <code>None</code> <code>min_length</code> <code>int</code> <p>Limits generation to words with at least the given length.</p> <code>0</code> <code>max_length</code> <code>Optional[int]</code> <p>Limits generation to words with at most the given length.</p> <code>None</code> <p>Returns:</p> Type Description <code>Generator[str, None, None]</code> <p>A generator for all strings that come before the input string in lexicographical order.</p> <p>Raises:</p> Type Description <code>InfiniteLanguageException</code> <p>Raised if the language accepted by self is infinite, as we cannot generate predecessors in this case.</p>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA.random_word","title":"<code>random_word(k, *, seed=None)</code>","text":"<p>Returns a random word of length k accepted by self.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>The length of the desired word.</p> required <code>seed</code> <code>Optional[int]</code> <p>The random seed to use for the sampling of the random word.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A uniformly random word of length k accepted by the DFA self.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If this DFA does not accept any words of length k.</p>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA.read_input_stepwise","title":"<code>read_input_stepwise(input_str, ignore_rejection=False)</code>","text":"<p>Return a generator that yields each step while reading input.</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>The input string to read.</p> required <code>ignore_rejection</code> <code>bool</code> <p>Whether to throw an exception if the input string is rejected.</p> <code>False</code> <p>Yields:</p> Type Description <code>Generator[DFAStateT, None, None]</code> <p>A generator that yields the current configuration of the DFA after each step of reading input.</p> <p>Raises:</p> Type Description <code>RejectionException</code> <p>Raised if this DFA does not accept the input string.</p>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA.successor","title":"<code>successor(input_str, *, strict=True, key=None, min_length=0, max_length=None)</code>","text":"<p>Returns the first string accepted by the DFA that comes after the input string in lexicographical order.</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>Optional[str]</code> <p>The starting input string. If None, will generate all words.</p> required <code>strict</code> <code>bool</code> <p>If set to false and input_str is accepted by the DFA, input_str will be returned.</p> <code>True</code> <code>key</code> <code>Optional[Callable]</code> <p>Function for defining custom lexicographical ordering. Defaults to using the standard string ordering.</p> <code>None</code> <code>min_length</code> <code>int</code> <p>Limits generation to words with at least the given length.</p> <code>0</code> <code>max_length</code> <code>Optional[int]</code> <p>Limits generation to words with at most the given length.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The first string accepted by the DFA lexicographically before input_string.</p>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA.successors","title":"<code>successors(input_str, *, strict=True, key=None, reverse=False, min_length=0, max_length=None)</code>","text":"<p>Generates all strings that come after the input string in lexicographical order.</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>Optional[str]</code> <p>The starting input string. If None, will generate all words.</p> required <code>strict</code> <code>bool</code> <p>If set to false and input_str is accepted by the DFA, input_str will be returned.</p> <code>True</code> <code>key</code> <code>Optional[Callable]</code> <p>Function for defining custom lexicographical ordering. Defaults to using the standard string ordering.</p> <code>None</code> <code>reverse</code> <code>bool</code> <p>If True, then predecessors will be generated instead of successors.</p> <code>False</code> <code>min_length</code> <code>int</code> <p>Limits generation to words with at least the given length.</p> <code>0</code> <code>max_length</code> <code>Optional[int]</code> <p>Limits generation to words with at most the given length.</p> <code>None</code> <p>Returns:</p> Type Description <code>Generator[str, None, None]</code> <p>A generator for all strings that come after the input string in lexicographical order.</p>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA.symmetric_difference","title":"<code>symmetric_difference(other, *, retain_names=False, minify=True)</code>","text":"<p>Takes as input two DFAs M1 and M2 which accept languages L1 and L2 respectively. Returns a DFA which accepts the symmetric difference of L1 and L2.</p> <p>Minifies by default. Unreachable states are always removed. If either input DFA is partial, the result is partial.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>DFA</code> <p>The DFA we want to take a symmetric difference with.</p> required <code>retain_names</code> <code>bool</code> <p>Whether to retain state names through the symmetric difference and optional minify.</p> <code>False</code> <code>minify</code> <code>bool</code> <p>Whether to minify the result of the symmetric difference of the two DFAs.</p> <code>True</code> <p>Returns:</p> Type Description <code>Self</code> <p>A DFA accepting the symmetric difference of the two input DFAs. State minimal by default.</p>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA.to_complete","title":"<code>to_complete(trap_state=None)</code>","text":"<p>Creates an equivalent complete DFA with trap_state used as the name for an added trap state. If trap_state is not passed in, defaults to the largest negative integer which is not already a state name. If the DFA is already complete, just returns a copy.</p> <p>Parameters:</p> Name Type Description Default <code>trap_state</code> <code>Optional[DFAStateT]</code> <p>Name for custom trap state to be used.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>An equivalent complete DFA.</p>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA.to_partial","title":"<code>to_partial(*, retain_names=False, minify=True)</code>","text":"<p>Turns a DFA (complete or not) into a partial DFA. Removes dead states and trap states (except the initial state)     and all edges leading to them.</p> <p>Parameters:</p> Name Type Description Default <code>minify</code> <code>bool</code> <p>Whether to perform a minify operation while converting to a partial DFA.</p> <code>True</code> <code>retain_names</code> <code>bool</code> <p>Whether to retain state names during minification.</p> <code>True</code> <p>Returns:</p> Type Description <code>Self</code> <p>An equivalent partial DFA.</p>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA.union","title":"<code>union(other, *, retain_names=False, minify=True)</code>","text":"<p>Takes as input two DFAs M1 and M2 which accept languages L1 and L2 respectively. Returns a DFA which accepts the union of L1 and L2.</p> <p>Minifies by default. Unreachable states are always removed. If either input DFA is partial, the result is partial.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>DFA</code> <p>The DFA we want to take a union with.</p> required <code>retain_names</code> <code>bool</code> <p>Whether to retain state names through the union and optional minify.</p> <code>False</code> <code>minify</code> <code>bool</code> <p>Whether to minify the result of the union of the two DFAs.</p> <code>True</code> <p>Returns:</p> Type Description <code>Self</code> <p>A DFA accepting the union of the two input DFAs. State minimal by default.</p>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA.universal_language","title":"<code>universal_language(input_symbols)</code>  <code>classmethod</code>","text":"<p>Directly computes the minimal DFA accepting all strings.</p> <p>Parameters:</p> Name Type Description Default <code>input_symbols</code> <code>AbstractSet[str]</code> <p>The set of input symbols to construct the DFA over.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The DFA accepting the desired language.</p>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA.validate","title":"<code>validate()</code>","text":"<p>Raises an exception if this automaton is not internally consistent.</p> <p>Raises:</p> Type Description <code>InvalidStateError</code> <p>If this DFA has invalid states in the transition dictionary.</p> <code>MissingStateError</code> <p>If this DFA has states missing from the transition dictionary.</p> <code>InvalidSymbolError</code> <p>If this DFA has invalid symbols in the transition dictionary.</p> <code>MissingSymbolError</code> <p>If this DFA is missing transitions on certain symbols.</p>"},{"location":"api/fa/class-dfa/#automata.fa.dfa.DFA.words_of_length","title":"<code>words_of_length(k)</code>","text":"<p>Generates all words of length <code>k</code> in the language accepted by the DFA.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>The desired word length.</p> required <p>Returns:</p> Type Description <code>Generator[str, None, None]</code> <p>A generator for all words of length k accepted by the DFA.</p>"},{"location":"api/fa/class-fa/","title":"class FA(Automaton, metaclass=ABCMeta)","text":"<p>Classes and methods for working with all finite automata.</p>"},{"location":"api/fa/class-fa/#automata.fa.fa.FA","title":"<code>FA</code>","text":"<p>               Bases: <code>Automaton</code></p> <p>The <code>FA</code> class is an abstract base class from which all finite automata inherit. Every subclass of FA can be rendered natively inside of a Jupyter notebook (automatically calling <code>diagram</code> property) if installed with the <code>visual</code> optional dependency.</p>"},{"location":"api/fa/class-fa/#automata.fa.fa.FA.diagram","title":"<code>diagram</code>  <code>cached</code> <code>property</code>","text":"<p>Returns:</p> Type Description <code>AGraph</code> <p>A diagram of this automaton.</p>"},{"location":"api/fa/class-fa/#automata.fa.fa.FA.iter_transitions","title":"<code>iter_transitions()</code>  <code>abstractmethod</code>","text":"<p>Iterate over all transitions in the automaton. Each transition is a tuple of the form (from_state, to_state, symbol)</p>"},{"location":"api/fa/class-fa/#automata.fa.fa.FA.show_diagram","title":"<code>show_diagram(input_str=None, path=None, *, layout_method='dot', horizontal=True, reverse_orientation=False, fig_size=None, font_size=14.0, arrow_size=0.85, state_separation=0.5)</code>","text":"<p>Generates a diagram of the associated automaton.</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>Optional[str]</code> <p>String consisting of input symbols. If set, will add processing of the input string to the diagram.</p> <code>None</code> <code>path</code> <code>Union[str, PathLike, None]</code> <p>Path to output file. If None, the output will not be saved.</p> <code>None</code> <code>horizontal</code> <code>bool</code> <p>Direction of node layout in the output graph.</p> <code>True</code> <code>reverse_orientation</code> <code>bool</code> <p>Reverse direction of node layout in the output graph.</p> <code>False</code> <code>fig_size</code> <code>Union[Tuple[float, float], Tuple[float], None]</code> <p>Figure size.</p> <code>None</code> <code>font_size</code> <code>float</code> <p>Font size in the output graph.</p> <code>14.0</code> <code>arrow_size</code> <code>float</code> <p>Arrow size in the output graph.</p> <code>0.85</code> <code>state_separation</code> <code>float</code> <p>Distance between nodes in the output graph.</p> <code>0.5</code> <p>Returns:</p> Type Description <code>AGraph</code> <p>A diagram of the given automaton.</p>"},{"location":"api/fa/class-gnfa/","title":"class GNFA(FA)","text":"<p>Classes and methods for working with generalized non-deterministic finite automata.</p>"},{"location":"api/fa/class-gnfa/#automata.fa.gnfa.GNFA","title":"<code>GNFA</code>","text":"<p>               Bases: <code>FA</code></p> <p>The <code>GNFA</code> class is a subclass of <code>FA</code> and represents a generalized nondeterministic finite automaton.</p> <p>Its main usage is for conversion of DFAs and NFAs to regular expressions. Note that because of this, the <code>GNFA</code> doesn't support any binary operators or reading input (e.g. <code>read_input_stepwise</code>). Every GNFA can be rendered natively inside of- a Jupyter notebook (automatically calling <code>show_diagram</code> without any arguments) if installed with the <code>visual</code> optional dependency. Note that <code>input_str</code> cannot be set as an argument to <code>show_diagram</code>, as the <code>GNFA</code> does not read input.</p> <p>Except for <code>initial_state</code> and <code>final_state</code>, one transition goes from every state to every other state, and also from each state to itself. To accommodate this, transitions can be regular expressions and <code>None</code>, in addition to normal input symbols.</p> <p>Parameters:</p> Name Type Description Default <code>states</code> <code>AbstractSet[GNFAStateT]</code> <p>Set of the GNFA's valid states.</p> required <code>input_symbols</code> <code>AbstractSet[str]</code> <p>Set of the GNFA's valid input symbols, each of which is a singleton string.</p> required <code>transitions</code> <code>Mapping[GNFAStateT, Mapping[GNFAStateT, Optional[str]]]</code> <p>A dict with the transitions for each state, except <code>final_state</code>. Each key is a state name and each value is dict which maps a state (the key) to the transition expression (the value) or None. The transition expression is a regular expression (string) over <code>input_symbols</code>, and the following symbols only: <code>*</code>, <code>|</code>, <code>?</code>, <code>()</code>.</p> <p>This is a subset of the standard regular expressions using this package.</p> required <code>initial_state</code> <code>GNFAStateT</code> <p>The initial state for this GNFA. Has transitions going to every other state, but no transitions coming in from any other state.</p> required <code>final_state</code> <code>GNFAStateT</code> <p>A single final state for this GNFA. Has transitions coming in from every other state, but no transitions going to any other state. Must be different from the <code>initial_state</code>.</p> required"},{"location":"api/fa/class-gnfa/#automata.fa.gnfa.GNFA.from_dfa","title":"<code>from_dfa(target_dfa)</code>  <code>classmethod</code>","text":"<p>Initialize this GNFA as one equivalent to the given DFA.</p> <p>Parameters:</p> Name Type Description Default <code>target_dfa</code> <code>DFA</code> <p>The DFA to construct an equivalent GNFA for.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The GNFA accepting the language of the input DFA.</p>"},{"location":"api/fa/class-gnfa/#automata.fa.gnfa.GNFA.from_nfa","title":"<code>from_nfa(target_nfa)</code>  <code>classmethod</code>","text":"<p>Initialize this GNFA as one equivalent to the given NFA.</p> <p>Parameters:</p> Name Type Description Default <code>target_nfa</code> <code>NFA</code> <p>The NFA to construct an equivalent GNFA for.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The GNFA accepting the language of the input NFA.</p>"},{"location":"api/fa/class-gnfa/#automata.fa.gnfa.GNFA.iter_transitions","title":"<code>iter_transitions()</code>","text":"<p>Iterate over all transitions in the GNFA. Each transition is a tuple of the form (from_state, to_state, symbol).</p> <p>Returns:</p> Type Description <code>Generator[Tuple[GNFAStateT, GNFAStateT, str], None, None]</code> <p>The desired generator over the GNFA transitions.</p>"},{"location":"api/fa/class-gnfa/#automata.fa.gnfa.GNFA.to_regex","title":"<code>to_regex()</code>","text":"<p>Convert GNFA to regular expression.</p> <p>Returns:</p> Type Description <code>str</code> <p>A regular expression equivalent to the input GNFA.</p>"},{"location":"api/fa/class-gnfa/#automata.fa.gnfa.GNFA.validate","title":"<code>validate()</code>","text":"<p>Raises an exception if this automaton is not internally consistent.</p> <p>Raises:</p> Type Description <code>InvalidStateError</code> <p>If this GNFA has invalid states in the transition dictionary.</p> <code>MissingStateError</code> <p>If this GNFA has states missing from the transition dictionary.</p> <code>InvalidRegexError</code> <p>If this GNFA has invalid regex in the transition dictionary.</p>"},{"location":"api/fa/class-nfa/","title":"class NFA(FA)","text":"<p>Classes and methods for working with nondeterministic finite automata.</p>"},{"location":"api/fa/class-nfa/#automata.fa.nfa.NFA","title":"<code>NFA</code>","text":"<p>               Bases: <code>FA</code></p> <p>The <code>NFA</code> class is a subclass of <code>FA</code> and represents a nondeterministic finite automaton.</p> <p>Every NFA has the same five DFA properties: <code>state</code>, <code>input_symbols</code>, <code>transitions</code>, <code>initial_state</code>, and <code>final_states</code>. However, the structure of the <code>transitions</code> object has been modified slightly to accommodate the fact that a single state can have more than one transition for the same symbol. Therefore, instead of mapping a symbol to one end state in each sub-dict, each symbol is mapped to a set of end states.</p> <p>Every NFA can be rendered natively inside of a Jupyter notebook (automatically calling <code>show_diagram</code> without any arguments) if installed with the <code>visual</code> optional dependency.</p> <p>Parameters:</p> Name Type Description Default <code>states</code> <code>AbstractSet[NFAStateT]</code> <p>Set of the NFA's valid states.</p> required <code>input_symbols</code> <code>AbstractSet[str]</code> <p>Set of the NFA's valid input symbols, each of which is a singleton string.</p> required <code>transitions</code> <code>Mapping[NFAStateT, Mapping[str, AbstractSet[NFAStateT]]]</code> <p>Dict consisting of the transitions for each state. Each key is a state name, and each value is another dict which maps a symbol (the key) to a set of states (the value).</p> required <code>initial_state</code> <code>NFAStateT</code> <p>The initial state for this NFA.</p> required <code>final_states</code> <code>AbstractSet[NFAStateT]</code> <p>A set of final states for this NFA.</p> required"},{"location":"api/fa/class-nfa/#automata.fa.nfa.NFA.animate_reading_input","title":"<code>animate_reading_input(input_str, preview=False)</code>","text":"<p>Render the animation of the NFA reading the input string stepwise and save the animation in the media/ folder.</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>The input string to read.</p> required <code>preview</code> <code>bool</code> <p>If true, opens scene in a file viewer.</p> <code>False</code>"},{"location":"api/fa/class-nfa/#automata.fa.nfa.NFA.concatenate","title":"<code>concatenate(other)</code>","text":"<p>Given two NFAs, M1 and M2, which accept the languages L1 and L2 respectively, returns an NFA which accepts the language L1 concatenated with L2.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>NFA</code> <p>The NFA we want to concatenate with.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>An NFA accepting the language concatenation of the two input NFAs.</p>"},{"location":"api/fa/class-nfa/#automata.fa.nfa.NFA.edit_distance","title":"<code>edit_distance(input_symbols, reference_str, max_edit_distance, *, insertion=True, deletion=True, substitution=True)</code>  <code>classmethod</code>","text":"<p>Constructs the Levenshtein NFA for the given reference_str and given Levenshtein distance. This NFA recognizes strings within the given Levenshtein distance (commonly called edit distance) of the reference_str. Parameters control which error types the NFA will recognize (insertions, deletions, or substitutions). At least one error type must be set.</p> <p>If insertion and deletion are False and substitution is True, then this is the same as Hamming distance.</p> <p>If insertion and deletion are True and substitution is False, then this is the same as LCS distance.</p> <p>insertion, deletion, and substitution all default to True.</p> <p>Code adapted from: http://blog.notdot.net/2010/07/Damn-Cool-Algorithms-Levenshtein-Automata</p> <p>Parameters:</p> Name Type Description Default <code>input_symbols</code> <code>AbstractSet[str]</code> <p>The set of input symbols to construct the NFA over.</p> required <code>reference_str</code> <code>str</code> <p>The reference string the NFA will use to recognize other close strings.</p> required <code>max_edit_distance</code> <code>int</code> <p>The maximum edit distance from the reference string this NFA will recognize. Must be positive.</p> required <code>insertion</code> <code>bool</code> <p>Whether to recognize insertion edits relative to the reference string.</p> <code>True</code> <code>deletion</code> <code>bool</code> <p>Whether to recognize deletion edits relative to the reference string.</p> <code>True</code> <code>substitution</code> <code>bool</code> <p>Whether to recognize substitution edits relative to the reference string.</p> <code>True</code> <p>Returns:</p> Type Description <code>Self</code> <p>An NFA accepting all strings within the given edit distance to the reference string.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Raised if the max_edit_distance is negative or all of the error flags are set to False (at least one must be True).</p>"},{"location":"api/fa/class-nfa/#automata.fa.nfa.NFA.eliminate_lambda","title":"<code>eliminate_lambda()</code>","text":"<p>Returns an equivalent NFA with lambda transitions removed.</p> <p>Returns:</p> Type Description <code>Self</code> <p>The equivalent NFA with lambda transitions removed.</p>"},{"location":"api/fa/class-nfa/#automata.fa.nfa.NFA.from_dfa","title":"<code>from_dfa(target_dfa)</code>  <code>classmethod</code>","text":"<p>Initialize this NFA as one equivalent to the given DFA.</p> <p>Parameters:</p> Name Type Description Default <code>target_dfa</code> <code>DFA</code> <p>The DFA to construct an equivalent NFA for.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The NFA accepting the language of the input DFA.</p>"},{"location":"api/fa/class-nfa/#automata.fa.nfa.NFA.from_regex","title":"<code>from_regex(regex, *, input_symbols=None)</code>  <code>classmethod</code>","text":"<p>Initialize this NFA as one equivalent to the given regular expression.</p> <p>Parameters:</p> Name Type Description Default <code>regex</code> <code>str</code> <p>The regex to construct an equivalent NFA for.</p> required <code>input_symbols</code> <code>Optional[AbstractSet[str]]</code> <p>The set of input symbols to create the NFA over. If not set, defaults to all non-reserved characters found in the regex.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The NFA accepting the language of the input regex.</p>"},{"location":"api/fa/class-nfa/#automata.fa.nfa.NFA.intersection","title":"<code>intersection(other)</code>","text":"<p>Given two NFAs, M1 and M2, which accept the languages L1 and L2 respectively, returns an NFA which accepts the intersection of L1 and L2.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>NFA</code> <p>The NFA we want to take an intersection with.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>An NFA accepting the intersection of the two input NFAs.</p>"},{"location":"api/fa/class-nfa/#automata.fa.nfa.NFA.iter_transitions","title":"<code>iter_transitions()</code>","text":"<p>Iterate over all transitions in the NFA. Each transition is a tuple of the form (from_state, to_state, symbol).</p> <p>Returns:</p> Type Description <code>Generator[Tuple[NFAStateT, NFAStateT, str], None, None]</code> <p>The desired generator over the NFA transitions.</p>"},{"location":"api/fa/class-nfa/#automata.fa.nfa.NFA.kleene_star","title":"<code>kleene_star()</code>","text":"<p>Given an NFA which accepts the language L, returns an NFA which accepts L repeated 0 or more times.</p> <p>Returns:</p> Type Description <code>Self</code> <p>An NFA accepting the finite repetition of the input NFA.</p>"},{"location":"api/fa/class-nfa/#automata.fa.nfa.NFA.left_quotient","title":"<code>left_quotient(other)</code>","text":"<p>Given two NFAs, M1 and M2, which accept the languages L1 and L2 respectively, returns an NFA which accepts the left quotient of L1 with respect to L2 (L2  L1).</p> <p>Construction is based off of the one described here: https://cs.stackexchange.com/a/102043</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>NFA</code> <p>The NFA we want to take a left quotient with.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>An NFA accepting the left quotient of the two input NFAs.</p>"},{"location":"api/fa/class-nfa/#automata.fa.nfa.NFA.option","title":"<code>option()</code>","text":"<p>Given an NFA which accepts the language L, returns an NFA which accepts L repeated 0 or 1 times.</p> <p>Returns:</p> Type Description <code>Self</code> <p>An NFA accepting the optional of the input NFA.</p>"},{"location":"api/fa/class-nfa/#automata.fa.nfa.NFA.read_input_stepwise","title":"<code>read_input_stepwise(input_str)</code>","text":"<p>Return a generator that yields the configuration of this NFA at each step while reading input.</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>The input string to read.</p> required <p>Yields:</p> Type Description <code>Generator[AbstractSet[NFAStateT], None, None]</code> <p>A generator that yields the current configuration (a set of states) of the NFA after each step of reading input.</p> <p>Raises:</p> Type Description <code>RejectionException</code> <p>Raised if this NFA does not accept the input string.</p>"},{"location":"api/fa/class-nfa/#automata.fa.nfa.NFA.reverse","title":"<code>reverse()</code>","text":"<p>Given an NFA which accepts the language L, returns an NFA which accepts the reverse of L.</p> <p>Returns:</p> Type Description <code>Self</code> <p>An NFA accepting the reversal of the input NFA.</p>"},{"location":"api/fa/class-nfa/#automata.fa.nfa.NFA.right_quotient","title":"<code>right_quotient(other)</code>","text":"<p>Given two NFAs, M1 and M2, which accept the languages L1 and L2 respectively, returns an NFA which accepts the right quotient of L1 with respect to L2 (L1 / L2).</p> <p>Construction is based off of the one described here: https://cs.stackexchange.com/a/102043</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>NFA</code> <p>The NFA we want to take a right quotient with.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>An NFA accepting the right quotient of the two input NFAs.</p>"},{"location":"api/fa/class-nfa/#automata.fa.nfa.NFA.shuffle_product","title":"<code>shuffle_product(other)</code>","text":"<p>Given two NFAs, M1 and M2, which accept the languages L1 and L2 respectively, returns an NFA which accepts the shuffle of L1 and L2.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>NFA</code> <p>The NFA we want to take a shuffle product with.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>An NFA accepting the shuffle product of the two input NFAs.</p>"},{"location":"api/fa/class-nfa/#automata.fa.nfa.NFA.union","title":"<code>union(other)</code>","text":"<p>Given two NFAs, M1 and M2, which accept the languages L1 and L2 respectively, returns an NFA which accepts the union of L1 and L2.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>NFA</code> <p>The NFA we want to take a union with.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>An NFA accepting the union of the two input NFAs.</p>"},{"location":"api/fa/class-nfa/#automata.fa.nfa.NFA.validate","title":"<code>validate()</code>","text":"<p>Raises an exception if this automaton is not internally consistent.</p> <p>Raises:</p> Type Description <code>InvalidStateError</code> <p>If this NFA has invalid states in the transition dictionary.</p> <code>MissingStateError</code> <p>If this NFA has states missing from the transition dictionary.</p> <code>InvalidSymbolError</code> <p>If this NFA has invalid symbols in the transition dictionary.</p>"},{"location":"api/pda/class-dpda/","title":"class DPDA(PDA)","text":"<p>Classes and methods for working with deterministic pushdown automata.</p>"},{"location":"api/pda/class-dpda/#automata.pda.dpda.DPDA","title":"<code>DPDA</code>","text":"<p>               Bases: <code>PDA</code></p> <p>The <code>DPDA</code> class is a subclass of <code>PDA</code> and represents a deterministic pushdown automaton.</p> <p>Parameters:</p> Name Type Description Default <code>states</code> <code>AbstractSet[DPDAStateT]</code> <p>A set of the DPDA's valid states</p> required <code>input_symbols</code> <code>AbstractSet[str]</code> <p>Set of the DPDA's valid input symbols, each of which is a singleton string.</p> required <code>stack_symbols</code> <code>AbstractSet[str]</code> <p>Set of the DPDA's valid stack symbols, each of which is a singleton string.</p> required <code>transitions</code> <code>DPDATransitionsT</code> <p>A dict consisting of the transitions for each state; see the example below for the exact syntax</p> required <code>initial_state</code> <code>DPDAStateT</code> <p>The name of the initial state for this DPDA.</p> required <code>initial_stack_symbol</code> <code>str</code> <p>The name of the initial symbol on the stack for this DPDA.</p> required <code>final_states</code> <code>AbstractSet[DPDAStateT]</code> <p>A set of final states for this DPDA.</p> required <code>acceptance_mode</code> <code>PDAAcceptanceModeT</code> <p>A string defining whether this DPDA accepts by <code>'final_state'</code>, <code>'empty_stack'</code>, or <code>'both'</code>.</p> <code>'both'</code> Example <pre><code>from automata.pda.dpda import DPDA\n# DPDA which which matches zero or more 'a's, followed by the same\n# number of 'b's (accepting by final state)\ndpda = DPDA(\n    states={'q0', 'q1', 'q2', 'q3'},\n    input_symbols={'a', 'b'},\n    stack_symbols={'0', '1'},\n    transitions={\n        'q0': {\n            'a': {'0': ('q1', ('1', '0'))}  # push '1' to stack\n        },\n        'q1': {\n            'a': {'1': ('q1', ('1', '1'))},  # push '1' to stack\n            'b': {'1': ('q2', '')}  # pop from stack\n        },\n        'q2': {\n            'b': {'1': ('q2', '')},  # pop from stack\n            '': {'0': ('q3', ('0',))}  # no change to stack\n        }\n    },\n    initial_state='q0',\n    initial_stack_symbol='0',\n    final_states={'q3'},\n    acceptance_mode='final_state'\n)\n</code></pre>"},{"location":"api/pda/class-dpda/#automata.pda.dpda.DPDA.read_input_stepwise","title":"<code>read_input_stepwise(input_str)</code>","text":"<p>Return a generator that yields the configuration of this DPDA at each step while reading input.</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>The input string to read.</p> required <p>Yields:</p> Type Description <code>Generator[PDAConfiguration, None, None]</code> <p>A generator that yields the current configuration of the DPDA after each step of reading input.</p> <p>Raises:</p> Type Description <code>RejectionException</code> <p>Raised if this DPDA does not accept the input string.</p>"},{"location":"api/pda/class-npda/","title":"class NPDA(PDA)","text":"<p>Classes and methods for working with nondeterministic pushdown automata.</p>"},{"location":"api/pda/class-npda/#automata.pda.npda.NPDA","title":"<code>NPDA</code>","text":"<p>               Bases: <code>PDA</code></p> <p>The <code>NPDA</code> class is a subclass of <code>PDA</code> and represents a nondeterministic pushdown automaton.</p> <p>Parameters:</p> Name Type Description Default <code>states</code> <code>AbstractSet[NPDAStateT]</code> <p>A set of the NPDA's valid states</p> required <code>input_symbols</code> <code>AbstractSet[str]</code> <p>Set of the NPDA's valid input symbols, each of which is a singleton string.</p> required <code>stack_symbols</code> <code>AbstractSet[str]</code> <p>Set of the NPDA's valid stack symbols, each of which is a singleton string.</p> required <code>transitions</code> <code>NPDATransitionsT</code> <p>A dict consisting of the transitions for each state; see the example below for the exact syntax</p> required <code>initial_state</code> <code>NPDAStateT</code> <p>The name of the initial state for this NPDA.</p> required <code>initial_stack_symbol</code> <code>str</code> <p>The name of the initial symbol on the stack for this NPDA.</p> required <code>final_states</code> <code>AbstractSet[NPDAStateT]</code> <p>A set of final states for this NPDA.</p> required <code>acceptance_mode</code> <code>PDAAcceptanceModeT</code> <p>A string defining whether this NPDA accepts by <code>'final_state'</code>, <code>'empty_stack'</code>, or <code>'both'</code>.</p> <code>'both'</code> Example <pre><code>from automata.pda.npda import NPDA\n# NPDA which matches palindromes consisting of 'a's and 'b's\n# (accepting by final state)\n# q0 reads the first half of the word, q1 the other half, q2 accepts.\n# But we have to guess when to switch.\nnpda = NPDA(\n    states={'q0', 'q1', 'q2'},\n    input_symbols={'a', 'b'},\n    stack_symbols={'A', 'B', '#'},\n    transitions={\n        'q0': {\n            '': {\n                '#': {('q2', '#')},  # no change to stack\n            },\n            'a': {\n                '#': {('q0', ('A', '#'))},  # push 'A' to stack\n                'A': {\n                    ('q0', ('A', 'A')),  # push 'A' to stack\n                    ('q1', ''),  # pop from stack\n                },\n                'B': {('q0', ('A', 'B'))},  # push 'A' to stack\n            },\n            'b': {\n                '#': {('q0', ('B', '#'))},  # push 'B' to stack\n                'A': {('q0', ('B', 'A'))},  # push 'B' to stack\n                'B': {\n                    ('q0', ('B', 'B')),  # push 'B' to stack\n                    ('q1', ''),  # pop from stack\n                },\n            },\n        },\n        'q1': {\n            '': {'#': {('q2', '#')}},  # push '#' to (currently empty) stack\n            'a': {'A': {('q1', '')}},  # pop from stack\n            'b': {'B': {('q1', '')}},  # pop from stack\n        },\n    },\n    initial_state='q0',\n    initial_stack_symbol='#',\n    final_states={'q2'},\n    acceptance_mode='final_state'\n)\n</code></pre>"},{"location":"api/pda/class-npda/#automata.pda.npda.NPDA.read_input_stepwise","title":"<code>read_input_stepwise(input_str)</code>","text":"<p>Return a generator that yields the configuration of this NPDA at each step while reading input.</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>The input string to read.</p> required <p>Yields:</p> Type Description <code>Generator[Set[PDAConfiguration], None, None]</code> <p>A generator that yields the current configuration of the NPDA after each step of reading input.</p> <p>Raises:</p> Type Description <code>RejectionException</code> <p>Raised if this NPDA does not accept the input string.</p>"},{"location":"api/pda/class-pda/","title":"class PDA(Automaton, metaclass=ABCMeta)","text":"<p>Classes and methods for working with all pushdown automata.</p>"},{"location":"api/pda/class-pda/#automata.pda.pda.PDA","title":"<code>PDA</code>","text":"<p>               Bases: <code>Automaton</code></p> <p>An abstract base class for pushdown automata.</p>"},{"location":"api/pda/class-pda/#automata.pda.pda.PDA.iter_transitions","title":"<code>iter_transitions()</code>  <code>abstractmethod</code>","text":"<p>Iterate over all transitions in the automaton. Each transition is a tuple of the form (from_state, to_state, (input_symbol, stack_top_symbol, stack_push_symbols))</p>"},{"location":"api/pda/class-pda/#automata.pda.pda.PDA.show_diagram","title":"<code>show_diagram(input_str=None, with_machine=True, with_stack=True, path=None, *, layout_method='dot', horizontal=True, reverse_orientation=False, fig_size=None, font_size=14.0, arrow_size=0.85, state_separation=0.5)</code>","text":"<p>Generates the graph associated with the given PDA. Args:     - input_str (str, optional): String list of input symbols. Defaults to None.     - with_machine (bool, optional): Constructs the diagram with states and       transitions. Ignored if <code>input_str</code> is None. Default to True.     - with_stack (bool, optional): Constructs the diagram with stack and its       operations. Ignored if <code>input_str</code> is None. Default to True.     - path (str or os.PathLike, optional): Path to output file. If       None, the output will not be saved.     - horizontal (bool, optional): Direction of node layout. Defaults       to True.     - reverse_orientation (bool, optional): Reverse direction of node       layout. Defaults to False.     - fig_size (tuple, optional): Figure size. Defaults to None.     - font_size (float, optional): Font size. Defaults to 14.0.     - arrow_size (float, optional): Arrow head size. Defaults to 0.85.     - state_separation (float, optional): Node distance. Defaults to 0.5. Returns:     AGraph corresponding to the given automaton.</p>"},{"location":"api/pda/class-pda/#automata.pda.pda.PDA.validate","title":"<code>validate()</code>","text":"<p>Raises an exception if this automaton is not internally consistent.</p> <p>Raises:</p> Type Description <code>InvalidStateError</code> <p>If this PDA has invalid states in the transition dictionary.</p> <code>MissingStateError</code> <p>If this PDA has states missing from the transition dictionary.</p> <code>InvalidSymbolError</code> <p>If this PDA has invalid symbols in the transition dictionary.</p> <code>InvalidAcceptanceModeError</code> <p>If this PDA has an invalid acceptance mode.</p>"},{"location":"api/tm/class-dtm/","title":"class DTM(TM)","text":"<p>Classes and methods for working with deterministic Turing machines.</p>"},{"location":"api/tm/class-dtm/#automata.tm.dtm.DTM","title":"<code>DTM</code>","text":"<p>               Bases: <code>TM</code></p> <p>The <code>DTM</code> class is a subclass of <code>TM</code> and represents a deterministic Turing machine.</p> <p>Parameters:</p> Name Type Description Default <code>states</code> <code>AbstractSet[DTMStateT]</code> <p>A set of the DTM's valid states.</p> required <code>input_symbols</code> <code>AbstractSet[str]</code> <p>Set of the DTM's valid input symbols, each of which is a singleton string.</p> required <code>tape_symbols</code> <code>AbstractSet[str]</code> <p>Set of the DTM's valid tape symbols, each of which is a singleton string.</p> required <code>transitions</code> <code>DTMTransitionsT</code> <p>Dict consisting of the transitions for each state; each key is a state name, and each value is a dict which maps a symbol (the key) to a tuple consisting of the next state, the symbol to write on the tape, and the direction to move the tape head.</p> required <code>initial_state</code> <code>DTMStateT</code> <p>The name of the initial state for this DTM.</p> required <code>blank_symbol</code> <code>str</code> <p>A symbol from <code>tape_symbols</code> to be used as the blank symbol for this DTM.</p> required <code>final_states</code> <code>AbstractSet[DTMStateT]</code> <p>A set of final states for this DTM.</p> required Example <pre><code>from automata.tm.dtm import DTM\n# DTM which matches all strings beginning with '0's, and followed by\n# the same number of '1's\ndtm = DTM(\n    states={'q0', 'q1', 'q2', 'q3', 'q4'},\n    input_symbols={'0', '1'},\n    tape_symbols={'0', '1', 'x', 'y', '.'},\n    transitions={\n        'q0': {\n            '0': ('q1', 'x', 'R'),\n            'y': ('q3', 'y', 'R')\n        },\n        'q1': {\n            '0': ('q1', '0', 'R'),\n            '1': ('q2', 'y', 'L'),\n            'y': ('q1', 'y', 'R')\n        },\n        'q2': {\n            '0': ('q2', '0', 'L'),\n            'x': ('q0', 'x', 'R'),\n            'y': ('q2', 'y', 'L')\n        },\n        'q3': {\n            'y': ('q3', 'y', 'R'),\n            '.': ('q4', '.', 'R')\n        }\n    },\n    initial_state='q0',\n    blank_symbol='.',\n    final_states={'q4'}\n)\n</code></pre>"},{"location":"api/tm/class-dtm/#automata.tm.dtm.DTM.read_input_stepwise","title":"<code>read_input_stepwise(input_str)</code>","text":"<p>Return a generator that yields the configuration of this DTM at each step while reading input.</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>The input string to read.</p> required <p>Yields:</p> Type Description <code>Generator[TMConfiguration, None, None]</code> <p>A generator that yields the current configuration of the DTM after each step of reading input.</p>"},{"location":"api/tm/class-dtm/#automata.tm.dtm.DTM.validate","title":"<code>validate()</code>","text":"<p>Raises an exception if this automaton is not internally consistent.</p> <p>Raises:</p> Type Description <code>InvalidStateError</code> <p>If this DTM has invalid states in the transition dictionary.</p> <code>InvalidSymbolError</code> <p>If this DTM has invalid symbols in the transition dictionary.</p> <code>InvalidDirectionError</code> <p>If this DTM has a transition with an invalid direction.</p> <code>FinalStateError</code> <p>If this DTM has a transition on any final states.</p>"},{"location":"api/tm/class-mntm/","title":"class MNTM(TM)","text":"<p>Classes and methods for working with multitape nondeterministic Turing machines.</p>"},{"location":"api/tm/class-mntm/#automata.tm.mntm.MNTM","title":"<code>MNTM</code>","text":"<p>               Bases: <code>NTM</code></p> <p>The <code>MNTM</code> class is a subclass of <code>TM</code> and represents a multitape (non)deterministic Turing machine.</p> <p>Parameters:</p> Name Type Description Default <code>states</code> <code>AbstractSet[MNTMStateT]</code> <p>A set of the MNTM's valid states.</p> required <code>input_symbols</code> <code>AbstractSet[str]</code> <p>Set of the MNTM's valid input symbols, each of which is a singleton string.</p> required <code>tape_symbols</code> <code>AbstractSet[str]</code> <p>Set of the MNTM's valid tape symbols, each of which is a singleton string.</p> required <code>n_tapes</code> <code>int</code> <p>The number of tapes in this MNTM.</p> required <code>transitions</code> <code>MNTMTransitionsT</code> <p>Dict consisting of the transitions for each state; each key is a state name, and each value is a dict which maps a symbol (the key) to a list of tuples consisting of the next state, the symbol to write on the tape, and the direction to move the tape head.</p> required <code>initial_state</code> <code>MNTMStateT</code> <p>The name of the initial state for this MNTM.</p> required <code>blank_symbol</code> <code>str</code> <p>A symbol from <code>tape_symbols</code> to be used as the blank symbol for this MNTM.</p> required <code>final_states</code> <code>AbstractSet[MNTMStateT]</code> <p>A set of final states for this MNTM.</p> required Example <pre><code>from automata.tm.mntm import MNTM\n# MNTM which accepts all strings in {0, 1}* and writes all\n# 1's from the first tape (input) to the second tape.\nself.mntm1 = MNTM(\n    states={'q0', 'q1'},\n    input_symbols={'0', '1'},\n    tape_symbols={'0', '1', '#'},\n    n_tapes=2,\n    transitions={\n        'q0': {\n            ('1', '#'): [('q0', (('1', 'R'), ('1', 'R')))],\n            ('0', '#'): [('q0', (('0', 'R'), ('#', 'N')))],\n            ('#', '#'): [('q1', (('#', 'N'), ('#', 'N')))],\n        }\n    },\n    initial_state='q0',\n    blank_symbol='#',\n    final_states={'q1'},\n)\n</code></pre>"},{"location":"api/tm/class-mntm/#automata.tm.mntm.MNTM.read_input_as_ntm","title":"<code>read_input_as_ntm(input_str)</code>","text":"<p>Simulates this MNTM as a single-tape Turing machine. Yields the configuration at each step.</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>The input string to read.</p> required <p>Yields:</p> Type Description <code>Generator[AbstractSet[TMConfiguration], None, None]</code> <p>A generator that yields the current configuration of the MNTM as a set after each step of reading input.</p> <p>Raises:</p> Type Description <code>RejectionException</code> <p>Raised if this MNTM does not accept the input string.</p>"},{"location":"api/tm/class-mntm/#automata.tm.mntm.MNTM.read_input_stepwise","title":"<code>read_input_stepwise(input_str)</code>","text":"<p>Checks if the given string is accepted by this MNTM machine, using a BFS of every possible configuration from each configuration. Yields the current configuration of the machine at each step.</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>The input string to read.</p> required <p>Yields:</p> Type Description <code>Generator[Set[MTMConfiguration], None, None]</code> <p>A generator that yields the current configuration of the DTM after each step of reading input.</p> <p>Raises:</p> Type Description <code>RejectionException</code> <p>Raised if this MNTM does not accept the input string.</p>"},{"location":"api/tm/class-mntm/#automata.tm.mntm.MNTM.validate","title":"<code>validate()</code>","text":"<p>Raises an exception if this automaton is not internally consistent.</p> <p>Raises:</p> Type Description <code>InvalidStateError</code> <p>If this MNTM has invalid states in the transition dictionary.</p> <code>InvalidSymbolError</code> <p>If this MNTM has invalid symbols in the transition dictionary.</p> <code>InvalidDirectionError</code> <p>If this MNTM has a transition with an invalid direction.</p> <code>FinalStateError</code> <p>If this MNTM has a transition on any final states.</p> <code>InconsistentTapesException</code> <p>If this MNTM has inconsistent tape contents.</p>"},{"location":"api/tm/class-ntm/","title":"class NTM(TM)","text":"<p>Classes and methods for working with nondeterministic Turing machines.</p>"},{"location":"api/tm/class-ntm/#automata.tm.ntm.NTM","title":"<code>NTM</code>","text":"<p>               Bases: <code>TM</code></p> <p>The <code>NTM</code> class is a subclass of <code>TM</code> and represents a nondeterministic Turing machine.</p> <p>Parameters:</p> Name Type Description Default <code>states</code> <code>AbstractSet[NTMStateT]</code> <p>A set of the NTM's valid states.</p> required <code>input_symbols</code> <code>AbstractSet[str]</code> <p>Set of the NTM's valid input symbols, each of which is a singleton string.</p> required <code>tape_symbols</code> <code>AbstractSet[str]</code> <p>Set of the NTM's valid tape symbols, each of which is a singleton string.</p> required <code>transitions</code> <code>NTMTransitionsT</code> <p>Dict consisting of the transitions for each state; each key is a state name, and each value is a dict which maps a symbol (the key) to a set of tuples consisting of the next state, the symbol to write on the tape, and the direction to move the tape head.</p> required <code>initial_state</code> <code>NTMStateT</code> <p>The name of the initial state for this NTM.</p> required <code>blank_symbol</code> <code>str</code> <p>A symbol from <code>tape_symbols</code> to be used as the blank symbol for this NTM.</p> required <code>final_states</code> <code>AbstractSet[NTMStateT]</code> <p>A set of final states for this NTM.</p> required Example <pre><code>from automata.tm.ntm import NTM\n# NTM which matches all strings beginning with '0's, and followed by\n# the same number of '1's\n# Note that the nondeterminism is not really used here.\nntm = NTM(\n    states={'q0', 'q1', 'q2', 'q3', 'q4'},\n    input_symbols={'0', '1'},\n    tape_symbols={'0', '1', 'x', 'y', '.'},\n    transitions={\n        'q0': {\n            '0': {('q1', 'x', 'R')},\n            'y': {('q3', 'y', 'R')},\n        },\n        'q1': {\n            '0': {('q1', '0', 'R')},\n            '1': {('q2', 'y', 'L')},\n            'y': {('q1', 'y', 'R')},\n        },\n        'q2': {\n            '0': {('q2', '0', 'L')},\n            'x': {('q0', 'x', 'R')},\n            'y': {('q2', 'y', 'L')},\n        },\n        'q3': {\n            'y': {('q3', 'y', 'R')},\n            '.': {('q4', '.', 'R')},\n        }\n    },\n    initial_state='q0',\n    blank_symbol='.',\n    final_states={'q4'}\n)\n</code></pre>"},{"location":"api/tm/class-ntm/#automata.tm.ntm.NTM.read_input_stepwise","title":"<code>read_input_stepwise(input_str)</code>","text":"<p>Check if the given string is accepted by this Turing machine.</p> <p>Yield the current configurations of the machine at each step.</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>The input string to read.</p> required <p>Yields:</p> Type Description <code>Generator[Set[TMConfiguration], None, None]</code> <p>A generator that yields the current configuration of the NTM after each step of reading input.</p> <p>Raises:</p> Type Description <code>RejectionException</code> <p>Raised if this NTM does not accept the input string.</p>"},{"location":"api/tm/class-ntm/#automata.tm.ntm.NTM.validate","title":"<code>validate()</code>","text":"<p>Raises an exception if this automaton is not internally consistent.</p> <p>Raises:</p> Type Description <code>InvalidStateError</code> <p>If this NTM has invalid states in the transition dictionary.</p> <code>InvalidSymbolError</code> <p>If this NTM has invalid symbols in the transition dictionary.</p> <code>InvalidDirectionError</code> <p>If this NTM has a transition with an invalid direction.</p> <code>FinalStateError</code> <p>If this NTM has a transition on any final states.</p>"},{"location":"api/tm/class-tm/","title":"class TM(Automaton, metaclass=ABCMeta)","text":"<p>Classes and methods for working with all Turing machines.</p>"},{"location":"api/tm/class-tm/#automata.tm.tm.TM","title":"<code>TM</code>","text":"<p>               Bases: <code>Automaton</code></p> <p>An abstract base class for Turing machines.</p>"},{"location":"api/tm/tm-exception-classes/","title":"Turing machine exception classes","text":"<p>Exception classes specific to Turing machines.</p>"},{"location":"api/tm/tm-exception-classes/#automata.tm.exceptions.InconsistentTapesException","title":"<code>InconsistentTapesException</code>","text":"<p>               Bases: <code>TMException</code></p> <p>The number of tapes defined for the multitape Turing machine is not consistent with the definitions of the transitions.</p>"},{"location":"api/tm/tm-exception-classes/#automata.tm.exceptions.InvalidDirectionError","title":"<code>InvalidDirectionError</code>","text":"<p>               Bases: <code>TMException</code></p> <p>A direction is not a valid direction for this machine.</p>"},{"location":"api/tm/tm-exception-classes/#automata.tm.exceptions.MalformedExtendedTapeError","title":"<code>MalformedExtendedTapeError</code>","text":"<p>               Bases: <code>TMException</code></p> <p>Extended tape for simulating an mntm as a ntm is not valid. Either there are 2 virtual heads for a virtual tape or the a head symbol is at the leftmost end of a virtual tape.</p>"},{"location":"api/tm/tm-exception-classes/#automata.tm.exceptions.TMException","title":"<code>TMException</code>","text":"<p>               Bases: <code>AutomatonException</code></p> <p>The base class for all machine-related errors.</p>"},{"location":"examples/fa-examples/","title":"Finite Automata Examples","text":"<p>On this page, we give some short examples with discussion for the finite automata (sometimes called finite state machines) classes and methods in this package. At a high level, a finite automaton (FA) is an abstract machine that can be in any one of a finite number of states, and moves between states based on a transition function in response to reading characters from an input string. The FA will accept or reject an input string depending on its current state.</p> <p>For a detailed overview of this topic, see this Wikipedia article or these lecture notes.</p>"},{"location":"examples/fa-examples/#reading-input","title":"Reading input","text":"<p>In this example, we first define a function that takes in an automaton and asks the user for input strings, printing whether the input was accepted or rejected:</p> <pre><code>def read_user_input(my_automaton):\n    try:\n        while True:\n            if my_automaton.accepts_input(input(\"Please enter your input: \")):\n                print(\"Accepted\")\n            else:\n                print(\"Rejected\")\n    except KeyboardInterrupt:\n        print(\"\")\n</code></pre>"},{"location":"examples/fa-examples/#deterministic-finite-automaton-dfa","title":"Deterministic finite automaton (DFA)","text":"<p>To use this function, let's first define a DFA. For a detailed definiton, see this Wikipedia article on DFAs.</p> <pre><code>from automata.fa.dfa import DFA\n\n# DFA which matches all binary strings ending in an odd number of '1's\nmy_dfa = DFA(\n    states={'q0', 'q1', 'q2'},\n    input_symbols={'0', '1'},\n    transitions={\n        'q0': {'0': 'q0', '1': 'q1'},\n        'q1': {'0': 'q0', '1': 'q2'},\n        'q2': {'0': 'q2', '1': 'q1'}\n    },\n    initial_state='q0',\n    final_states={'q1'}\n)\n</code></pre> <p>We can generate a picture of our DFA using the package:</p> <pre><code>my_dfa.show_diagram()\n</code></pre> <p>This produces the following:</p> <p></p> <p>Now that we've defined our DFA, we can see our funciton in action:</p> <pre><code>read_user_input(my_dfa)\n# 001 -&gt; Accepted\n# 011 -&gt; Rejected\n# 000111 -&gt; Accepted\n</code></pre>"},{"location":"examples/fa-examples/#nondeterministic-finite-automaton-nfa","title":"Nondeterministic finite automaton (NFA)","text":"<p>We can also do the same with an NFA we define. Note that the transition dictionary for the NFA has a different structure than that of the DFA, and that we are working over a different input alphabet than the previous example. For a detailed definiton, see this Wikipedia article on NFAs.</p> <pre><code>from automata.fa.nfa import NFA\n\n# NFA which matches strings beginning with \"a\", ending with \"a\", and\n# containing no consecutive \"b\"s\nmy_nfa = NFA(\n    states={\"q0\", \"q1\", \"q2\"},\n    input_symbols={\"a\", \"b\"},\n    transitions={\n        \"q0\": {\"a\": {\"q1\"}},\n        \"q1\": {\"a\": {\"q1\"}, \"\": {\"q2\"}},\n        \"q2\": {\"b\": {\"q0\"}},\n    },\n    initial_state=\"q0\",\n    final_states={\"q1\"},\n)\n</code></pre> <p>Similar to the DFA, we can generate a picture of our NFA:</p> <pre><code>my_nfa.show_diagram()\n</code></pre> <p>This produces the following:</p> <p></p> <p>We can call our function as in the prior example:</p> <pre><code>read_user_input(my_nfa)\n# b -&gt; Rejected\n# aa -&gt; Accepted\n# abaa -&gt; Accepted\n</code></pre>"},{"location":"examples/fa-examples/#subset-for-nfas","title":"Subset for NFAs","text":"<p>The <code>NFA</code> does not have a built-in method for checking whether it is a subset of another <code>NFA</code>. However, this can be done using existing methods in the package:</p> <pre><code>import string\nfrom automata.fa.nfa import NFA\n\ndef is_subset(nfa1, nfa2):\n    # In the following, we have nfa1 and nfa2 and want to determine whether\n    # nfa1 is a subset of nfa2.\n\n    # If taking the union of nfa2 with nfa1 is equal to nfa2 again,\n    # nfa1 didn't accept any strings that nfa2 did not, so it is a subset.\n    return nfa1.union(nfa2) == nfa2\n</code></pre> <p>To see our function in action, we need to define some NFAs. We can do this easily by converting from regular expressions. For more information about this equivalence, see the Wikipedia article on regular languages:</p> <pre><code>alphabet = set(string.ascii_lowercase)\n\nnfa1 = NFA.from_regex(\"abc\", input_symbols=alphabet)\nnfa2 = NFA.from_regex(\"(abc)|(def)\", input_symbols=alphabet)\nnfa3 = NFA.from_regex(\"a*bc\", input_symbols=alphabet)\n</code></pre> <p>With these NFAs, we can now call the function and check that it matches the expected results.</p> <pre><code>print(is_subset(nfa1, nfa2))  # True\nprint(is_subset(nfa1, nfa3))  # True\nprint(is_subset(nfa2, nfa3))  # False\n</code></pre>"},{"location":"examples/fa-examples/#edit-distance-automaton","title":"Edit distance automaton","text":"<p>The following example is inspired by this blog post. Essentially, we want to determine which strings in a given set are within the target edit distance to a reference string. We do this by creating an edit distance NFA and intersecting it with a DFA recognizing our original set of strings:</p> <pre><code>import string\n\nfrom automata.fa.dfa import DFA\nfrom automata.fa.nfa import NFA\n\n\ndef words_within_edit_distance(edit_distance, reference_string, target_words):\n    input_symbols = set(string.ascii_lowercase)\n\n    # Construct DFA recognizing target words\n    target_words_dfa = DFA.from_finite_language(\n        input_symbols,\n        target_words,\n    )\n\n    # Next, construct NFA recognizing all strings\n    # within given edit distance of target word\n    words_within_edit_distance_dfa = DFA.from_nfa(\n        NFA.edit_distance(\n            input_symbols,\n            reference_string,\n            edit_distance,\n        )\n    )\n\n    # Take intersection and return results\n    found_words_dfa = target_words_dfa &amp; words_within_edit_distance_dfa\n    return set(found_words_dfa)\n\n\ntarget_words = {\"these\", \"are\", \"target\", \"words\", \"them\", \"those\"}\nreference_string = \"they\"\nedit_distance = 2\n\nfound_words = words_within_edit_distance(edit_distance, reference_string, target_words)\n\n# Set is {\"these\", \"them\"}\nprint(\n    f\"All words within edit distance {edit_distance} of \"\n    f\"'{reference_string}': {found_words}\"\n)\n</code></pre>"},{"location":"examples/fa-examples/#making-a-transition-table","title":"Making a transition table","text":"<p>The example below is adapted from the visual automata library. This function takes in a DFA or NFA and returns the corresponding transition table.</p> <p>The start state is prefixed with <code>\u2192</code> and final states are prefixed with <code>*</code>.</p> <pre><code>import pandas as pd\n\ndef make_table(target_fa) -&gt; pd.DataFrame:\n    initial_state = target_fa.initial_state\n    final_states = target_fa.final_states\n\n    table = {}\n\n    for from_state, to_state, symbol in target_fa.iter_transitions():\n        # Prepare nice string for from_state\n        if isinstance(from_state, frozenset):\n            from_state_str = str(set(from_state))\n        else:\n            from_state_str = str(from_state)\n\n        if from_state in final_states:\n            from_state_str = \"*\" + from_state_str\n        if from_state == initial_state:\n            from_state_str = \"\u2192\" + from_state_str\n\n        # Prepare nice string for to_state\n        if isinstance(to_state, frozenset):\n            to_state_str = str(set(to_state))\n        else:\n            to_state_str = str(to_state)\n\n        if to_state in final_states:\n            to_state_str = \"*\" + to_state_str\n\n        # Prepare nice symbol\n        if symbol == \"\":\n            symbol = \"\u03bb\"\n\n        from_state_dict = table.setdefault(from_state_str, dict())\n        from_state_dict.setdefault(symbol, set()).add(to_state_str)\n\n    # Reformat table for singleton sets\n    for symbol_dict in table.values():\n        for symbol in symbol_dict:\n            if len(symbol_dict[symbol]) == 1:\n                symbol_dict[symbol] = symbol_dict[symbol].pop()\n\n\n    df = pd.DataFrame.from_dict(table).fillna(\"\u2205\").T\n    return df.reindex(sorted(df.columns), axis=1)\n</code></pre>"},{"location":"examples/perf-examples/","title":"Performance Examples","text":"<p>On this page, we give examples of reading large inputs with the library. We include timing code in these examples to allow for comparisons with other implementations.</p>"},{"location":"examples/perf-examples/#edit-distance-automaton-for-large-dictionaries","title":"Edit distance automaton for large dictionaries","text":"<p>This is an extended version of the edit distance example on a large input. Here, we will return all words in the given English dictionary within the specified edit distance to the target word.</p> <pre><code># Imports from automata library\nimport string\nimport time\n\nimport pooch\n\nfrom automata.fa.dfa import DFA\nfrom automata.fa.nfa import NFA\n\n# First, get a set of all the words we'd like to use\nword_file = pooch.retrieve(\n    url=\"https://raw.githubusercontent.com/solardiz/wordlists/master/gutenberg-all-lowercase-words.txt\",\n    known_hash=\"62be81d8a5cb2dae11b96bdf85568436b137b9c0961340569ca1fca595774788\",\n)\n\nwith open(word_file, \"r\") as wf:\n    word_set = set(wf.read().splitlines())\n\n\nprint(f\"Word set size: {len(word_set):,}\")\n\n# Create the DFA recognizing all the words we'd like\n# NOTE this DFA is minimal by construction\nstart = time.perf_counter()\ninput_symbols = set(string.ascii_lowercase)\nword_dfa = DFA.from_finite_language(input_symbols, word_set)\nend = time.perf_counter()\n\nprint(f\"Created recognizing DFA in {end-start:4f} seconds.\")\nprint(f\"States in DFA: {len(word_dfa.states):,}\")\n\n# Create the automaton recognizing words close to our target\n# word from an NFA\ntarget_word = \"those\"\nedit_distance = 2\n\nedit_distance_dfa = DFA.from_nfa(\n    NFA.edit_distance(\n        input_symbols,\n        target_word,\n        edit_distance,\n    )\n)\n\n# Finally, take intersection and print results\nstart = time.perf_counter()\nfound_words_dfa = word_dfa &amp; edit_distance_dfa\nfound_words = list(found_words_dfa)\nend = time.perf_counter()\n\nprint(f\"DFA intersection done in {end-start:4f} seconds.\")\nprint(\n    f\"All words within edit distance {edit_distance} of \"\n    f'\"{target_word}\": {found_words}'\n)\n</code></pre> <p>Note that in this example, the DFA construction is taking place over a relatively large alphabet (26) and with a large number of words (&gt; 150,000).</p>"},{"location":"examples/perf-examples/#minimal-dfa-from-large-randomized-regex","title":"Minimal DFA from large randomized regex","text":"<p>In this example, we minimize the DFA from a large, randomly generated regular expression.</p> <pre><code># Do imports\nimport random\nimport time\n\nfrom automata.fa.dfa import DFA\nfrom automata.fa.nfa import NFA\n\n# Define regex parameters\nnum_clauses = 1_000\nclause_size = 50\n\n# Define the input symbols and randomly\n# construct the regex\ninput_symbols = [\"0\", \"1\"]\nraw_regex = \"|\".join(\n    \"\".join(random.choices(input_symbols, k=clause_size)) for _ in range(num_clauses)\n)\n\n# Convert the regex to NFA\nstart = time.perf_counter()\nregex_nfa = NFA.from_regex(raw_regex)\nend = time.perf_counter()\nprint(\n    f\"Created equivalent NFA with {len(regex_nfa.states):,} states in {end-start:4f} seconds.\"\n)\n\n# Convert to (minimized) DFA\nstart = time.perf_counter()\nregex_dfa = DFA.from_nfa(regex_nfa, minify=True)\nend = time.perf_counter()\n\n# Print timing and other information\nprint(\n    f\"Created equivalent minimized DFA with {len(regex_dfa.states):,} states in {end-start:4f} seconds.\"\n)\nprint(f\"Number of words accepted by DFA: {len(regex_dfa):,}.\")\nprint(f\"Minimum word length accepted by DFA: {regex_dfa.minimum_word_length():,}.\")\nprint(f\"Maximum word length accepted by DFA: {regex_dfa.minimum_word_length():,}.\")\n</code></pre>"}]}